codeforces/contests/div2/1005
------
codeforces/contests/div2/1005
https://codeforces.com/contest/2064
------
codeforces/contests/div2/1005
A.cpp
  아이디어
1. s의 suffix를 고를 때
뒤에서 부터 0을 0의 개수와는 상관없이 어떤 1을 찾을 때까지 ptr을 옮긴다.
1을 못찾았다면 flag = true를 한다.
만약 flag == true이면 연산을 하지 않는다.
1을 찾으면 1의 개수와는 상관 없이 0이 나오기 전까지 ptr을 옮긴다.
그것을 연산해 s의 ptr ~ s.length() - 1의 문자열을 t의 뒤에 옮긴다.

2. t의 suffix를 고를 때
s의 suffix를 고를 때와는 반대이다. 0을 찾을 때까지 ptr을 옮기고,
0을 못찾았다면 flag = true를 한다.
만약 flag == true이면 연산을 하지 않는다.
0을 찾으면 1이 나오기 전까지 ptr을 옮긴다.
그것을 연산해 t의 ptr ~ t.length() - 1의 문자열을 s의 뒤에 옮긴다.

연산을 한 횟수를 출력하면 된다.
위를 구현하면 된다.

  1번과 2번에 따라 연산을 했을 때
1번을 연산하면
계속해서 s에서 1을 지우면서 t의 앞에는 1이 연속해서 쌓이고,
2번을 연산하면
s의 뒤에는 0이 연속해서 쌓이면서 계속해서 t에서 0을 지울 수 있다.

  이게 최적의 방법인가?
핵심 아이디어는 우선 t는 비어있고, t에는 1을 쌓아야 할 것이다. 
그리고 기본적으로 0또는 1이 같은 문자가 연속된다면 연속된 것을 함께 옮기는 것이 최적의 방법이다.
따라서 연속된 1, 연속된 0은 하나의 문자로 생각하고 연산을 할 수 있다.
위와 같이 연속된 문자열을 하나의 문자로 생각을 한다면 0과 1이 반복한 것이 s의 문자열로 생각할 수 있다.
s가 가능한 모양은 다음과 같다.
0
1
01
10
010
101
0...0 = 01...10
0...1 = 01...01
1...0 = 10...10
1...1 = 10...01

위의 모양과 위의 아이디어의 도움을 받아 생각하면
우선 s에서 t로 옮길 문자열의 맨 앞이 0인 경우 연산 횟수는 최소 횟수에서 1회 또는 그 이상 늘어나게 된다.
따라서 우선 s에서 t로 옮길 문자열의 맨 앞은 1이어야 한다.

s에서 t로 문자열을 옮길 때 그 문자열의 맨 앞이 연속된 0이거나
t에서 s로 문자열을 옮길 때 그 문자열의 맨 앞이 연속된 1일 때의 경우도
최소 횟수에서 1회 또는 그 이상 늘어나게 된다.

------
  이후는 풀이 과정에서 정리한 생각이므로 중요하지 않다.
따라서 우선 s에서 t로 옮길 문자열의 맨 앞은 1이면
 옮긴 후에는 s의 뒤는 0이 모여있는 모양일 것이다.
현재 s의 뒤에 0이 모여 있으므로 t에서 s로 1을 뒤에 다시 옮겨온다면 
이것은 중복된 모양이고, 경우의 수를 생각해봐도 결과적으로 연산을 같은 횟수 또는 더 필요로 하게 된다.
따라서 s의 뒤에 0이 모여있어야 한다.

s에서 t로 옮길 문자열 모양
1. 10
2. 101 X
3. 1010
우선 위의 3가지 경우를 살펴보면
1번의 경우는 풀이와 같고, 0을 모아서 옮기면 t에는 1을 쌓을 수 있다.
2번의 경우는 t에서 s로 옮길 때 1을 다시 옮긴다면 위에서 정리한대로 연산횟수가 1번과 같거나 더 안좋은 모양이다.
3번의 경우는 t에 연속된 1을 남겨두고 결국 t에서 s로 0...1...0 모양을 옮겨야 한다.

0...1...0 모양을 정리하는 최적의 경우의 수는
t에서 s로 0...1...0을 옮기고,
s에서 t로 1...0을 옮겨오고,
t에서 s로 ...0을 옮기는 것이다.
이는 결과적으로 풀이에서 정리한 경우와 같고, 1번의 경우와 연산 횟수가 같다.
이외에도 다른 모양들의 경우의 수를 생각해봐도 더 좋은 경우는 없는 것 같다.