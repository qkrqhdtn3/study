codeforces/contests/div1Div2/1001
------
codeforces/contests/div1Div2/1001
https://codeforces.com/contest/2062
------
codeforces/contests/div1Div2/1001
B.cpp
  문제 설명
길이 n의 시간 수열 a가 주어진다. 
1. 1초마다 수열의 시간이 1씩 줄어든다. 어떤 수열의 시간이 0에 도달하면 패배한다. 
2. 인접한 시계로 이동하거나 움직이지 않을 수 있다.
3. 현재 위치한 인덱스 i를 골라 초기값을 a[i]로 reset할 수 있다.
위의 1~3은 순서대로 발생한다. 시간이 0에 도달하면 그 때 그곳으로 이동해 시간을 reset해도 패배한다.
어느 인덱스에서든 시작할 수 있다. 이 과정을 무한히 반복할 수 있으면 답은 YES, 아니면 NO이다.

  아이디어
우선 [4, 10], [4, 10, 5]의 예시로 문제의 해결법의 실마리를 생각해보자
아마도 계속해서 왼쪽 끝, 오른쪽 끝으로 움직이는 것이 가장 좋은 방법일 것이다.

길이가 작은 수열부터 가능한 가장 작은 수열의 예시를 구해보자
[a, b]
인덱스 1에서 시작
1. a-1, b-1 -> 1에서 1로 이동 -> a, b-1
2. a-1, b-2 -> 1에서 2로 이동 -> a-1, b
3. a-2, b-1 -> 2에서 1로 이동 -> a, b-1
4. a-1, b-2 -> 1에서 2로 이동 -> a-1, b
각각의 시간이 가지는 최소값은 a-2, b-2이고 0보다 커야한다. a>2, b>2 인 경우 만족한다.

[a, b, c]
인덱스 1에서 시작
1. a-1, b-1, c-1 -> 1에서 1로 이동 -> a, b-1, c-1
2. a-1, b-2, c-2 -> 1에서 2로 이동 -> a-1, b, c-2
3. a-2, b-1, c-3 -> 2에서 3로 이동 -> a-2, b-1, c
4. a-3, b-2, c-1 -> 3에서 2로 이동 -> a-3, b, c-1
5. a-4, b-1, c-2 -> 2에서 1로 이동 -> a, b-1, c-2
6. a-1, b-2, c-3 -> 1에서 2로 이동 -> a-1, b, c-3
7. a-2, b-1, c-4 -> 2에서 3로 이동 -> a-2, b-1, c
각각의 시간이 가지는 최소값은 a-4, b-2, c-4이고 0보다 커야한다. a>4, b>2, c>4 인 경우 만족한다.

위를
1. 인덱스 i의 a[i]값을 생각해보자
어떤 인덱스 i에서 양쪽 끝까지의 거리는 각각 i-1, n-i 이다.
본인의 위치까지 왕복하는 동안 시간은 각각 2 * (i - 1), 2 * (n - i)만큼 감소한다.
2. 초기 시작 위치를 생각해보자
어디서 시작하더라도 어떤 인덱스 i에 있어서 최악의 경우는 양쪽 끝 중에서 가장 먼 거리를 다녀 오는 것이 된다.
따라서 초기 시작 위치는 상관이 없다.
3. 결과적으로 생각해보면 먼 거리를 다녀올 때까지 시간이 0이 되지 않아야 한다.
따라서 a[i] > max(2 * (i - 1), 2 * (n - i))여야한다.
이를 구현하면 된다.

ex)
[3, 3], [5, 3, 5], [7, 5, 5, 7], [9, 7, 5, 7, 9], [11, 9, 7, 7, 9, 11] 와 같은 모양이 된다.
