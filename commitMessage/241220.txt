codeforce/contest/upsolving 991div3, upsolving global28
------
upsolving 991div3
https://codeforces.com/contest/2050
upsolving global28
https://codeforces.com/contest/2048
------
upsolving 991div3
  C.cpp
  조건
1. 길이 10^5 이하인 수 n을 입력받는다.
2. 숫자 하나를 선택해서 제곱해서 교체할 수 있다. 제곱했을 때 9이하여야 한다.
이 작업을 원하는만큼 수행할 수 있다.
3. 숫자 n을 조건 2번에 따라 수행했을 때 9로 나누어 떨어지는 수가 있는가?

  아이디어
1번 조건에 의해 string에 n을 입력받고,

2번 조건은 숫자 0 ~ 9의 경우를 나누면
0, 1은 제곱하면 0, 1이기에 영향이 없다.
2, 3은 제곱하면 4, 9이기에 영향이 있다.
4 ~ 9는 제곱했을 때 10이상이므로 작업을 수행할 수 없다.
따라서 2, 3의 개수가 답에 영향을 준다.

3번 조건은 9로 나누어 떨어지는 수는 모든 자리의 합이 9의 배수인 경우다.
2, 3은 제곱하면 2, 6 만큼 증가한다. 
2, 3은 각각 9개인 경우 합이 18, 54으로 9로 나누어 떨어진다.
따라서 2, 3은 각각 9개 이상인 9 * i + 0 ~ 8 개는 i와 상관 없이 0 ~ 8 개인 경우가 반복 된다.
(3은 3개 이상일 경우 3 * i + 0 ~ 2로 반복되긴 한다.)
따라서 if((sum + 2 * i + 6 * j) % 9 == 0)와 같은 조건식을 
i는 2의 개수, j는 3의 개수만큼 반복한다. i, j 값은 각각 8을 초과하면 값을 8로 만들어 주면 된다.

  dp 풀이 아이디어
위를 이해한 내용에 이어서 dp로 푸는 방법이다.
먼저 간단히 요약하자면,
현재 index에서 구하는 자릿수 합은 bool new_dp[9] 에 저장되고,
index - 1의 자릿수의 모든 경우는 bool dp[9] 배열에 저장되어 있다.
1 ~ n.length()까지 dp와 new_dp를 swap하며 답을 구한다.

숫자 n을 1 ~ n.length() 순서로 순회할 때,
1 ~ index - 1 까지의 가능한 자릿수 합이 dp에 저장되어 있다고 가정하면
그 모든 sum에 index번째의 숫자도 가능한 모든 경우의 수를 더해서 new_dp에 저장하는데, 그 sum을 9로 나눈 나머지를 new_dp에 저장한다.
이런 방식으로 1부터 마지막까지 반복하고,
그 index가 n.length() 까지 도달했을 때 if(dp[0] == true) 이면 9로 나눠지는 수이다.
------
  피드백
직관적으로 문제를 풀었을 때, 처음에 풀었던 방식인 i = 0 ~ 8, j = 0 ~ 8 인 반복문으로 if((sum + 2 * i + 6 * j) % 9 == 0) 을 확인하는 풀이 방법도 있고,
dp로 다시 풀어본 방식인 방법도 있다.
직관적으로 푸는 방법이 이해하기엔 더 쉽다.
문제와 그 풀이 방법을 잘 이해했을 때, dp인 방법도 더 이해하고 익히기 쉽다.