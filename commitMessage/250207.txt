codeforces/contests/div1Div2/1001
------
codeforces/contests/div1Div2/1001
https://codeforces.com/contest/2062
------
codeforces/contests/div1Div2/1001
C.cpp
  문제 설명
길이 n인 수열 a가 주어진다. a의 길이가 1인 경우가 아니면 두가지 연산을 어떤 횟수만큼 수행할 수 있다.
연산은 다음과 같다.
1. 수열을 역순으로 한다.
2. 수열을 이것의 difference sequence(계차 수열)로 바꾼다.
ex) [a1, a2, ..., an] 에 2번 연산을 수행한 후 [a2 - a1, a3 - a2, ... , an - a(n - 1)] 이 된다.
어떤 연산 후에 구할 수 있는 a의 요소의 합의 최대값을 구해야 한다.

  아이디어
시간복잡도에 대해서
간단하게 생각할 수 있는 brute force 방법으로 풀이하면 최악의 경우 연산은 대략 2^50 * n 번 정도일 것 같다.
따라서 규칙을 찾아야 한다.
1번 연산 이후에 모든 요소를 더하면 요소의 합은 변하지 않는다.
2번 연산 이후에 모든 요소를 더하면 요소의 합은 an - a1이 된다.
1. 1번 연산을 한 경우 2번 연산 이후에 배열의 요소
[a1 - a2, a2 - a3, ... , a(n - 1) - an] ... 배열을 역순으로 뒤집은 것
2. 1번 연산을 하지 않은 경우 2번 연산 이후에 배열의 요소
[a2 - a1, a3 - a2, ... , an - a(n - 1)]

1번 연산을 하고 2번 연산을 한 것의 요소는 
1번 연산을 하지 않고 2번 연산을 한 것의 요소에 -1을 곱한 것과 같다.
또한 길이는 2번 연산을 통해 줄어든다
따라서 줄어든 그 길이인 aLen인 배열의 합에 1을 곱하거나 -1을 곱한 두가지 경우가 
1번과 2번 연산에 대한 고려할 수 있는 모든 경우의 수와 같다.
간단하게 생각해서 2번 연산을 반복하며 1을 곱하거나 -1을 곱한 요소의 합 중에서 최대 값을 구하면 된다.