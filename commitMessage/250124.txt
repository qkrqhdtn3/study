codeforces/contests/div2/1000
------
codeforces/contests/div2/1000
https://codeforces.com/contest/2063
------
codeforces/contests/div2/1000
A.cpp
  아이디어
[l, r] 세그먼트에 포함된 최소 서로소 세그먼트의 수를 구하는 문제다.
최소 서로소는 자신과 같지 않은 서로소 세그먼트를 포함하지 않는다.
예시는 다음과 같다.
[l, r]과 [l`, r`]이 서로소 세그먼트이고, l <= l` <= r` <= r일 때,
l, r은 최소 서로소가 아니다.
ex) [1, 2] 세그먼트가 주어 졌을 때,
[1, 1] 1, 1은 서로소이고, 다른 서로소 세그먼트를 포함하지 않는다.
따라서 최소 서로소이다.
[1, 2] [1, 1]을 포함하므로 최소 서로소가 아니다.
[2, 2] 2, 2는 1이 아닌 수 2로 나눠지므로 서로소가 아니다.

어떤 정수 x와 x+1은 항상 서로소이다. 따라서 [x, x + 1]은 서로소이다.
x = 1인 경우, [1, 1]이 최소 서로소이다.
x >= 2인 경우, [x, x + 1]이 최소 서로소이다.
따라서 l = 1, r = 1이 아닌 경우 r - l이 최소 서로소 세그먼트의 수이다.

B.cpp
  아이디어
수열 a1, a2, ... , an과 세그먼트 [l, r]이 주어진다.
연산을 한 번 수행해서 a[l] + a[l + 1] + ... + a[r - 1] + a[r]의 최소값을 구해야 한다.

연산은 다음과 같다.
수열의 a의 부분 수열를 선택하고 뒤집는다.
부분 수열이 연속적이지 않아도 된다.
예를 들어 1 <= i1 < i2 < ... < ik <= n이 되도록 i1, i2, ... , ik를 선택했다면,
ix와 ik - x + 1의 값을 바꾼다.

i < l인 인덱스, j > r인 인덱스를 선택하고 연산한다면,
i, j인 [l, r]사이의 값이 변경되지 않으므로,
모든 인덱스가 1 <= i <= r이거나, l <= i <= n 인 경우에
오름차순으로 정렬한 작은 수부터 r - l + 1개의 수를 골라
각각의 최소의 합을 구해서 둘 중 작은 합이 답이다.