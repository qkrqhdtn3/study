codeforces/contests/div3 995
------
codeforces/contests/div3 995
https://codeforces.com/contest/2051
------
codeforces/contests/div3 995
D4.cpp
  풀이 방법
우선 풀 수 있는 방법은 두가지 있다.
[l, r]의 구간을 구해야 하는 경우

1. [0, r] 구간의 답에 [0, l - 1] 구간의 답을 빼면 [l, r] 구간의 답을 구할 수 있다.
이것은 D2.cpp, D3.cpp 에서 푼 방법이다.

2. [l, r] 구간의 답을 한번에 구하는 경우이다.
이것은 D4.cpp 에서 푼 방법이다.

시간복잡도는 1번이 O(n) 2번이 O(nlogn)이다.


  아이디어 2. [l, r] 구간의 답을 한번에 구하는 경우
x <= sum - a[i] - a[j] <= y
위를 만족하는 i, j 쌍의 개수를 구하는 문제다.
sum은 주어진 원소의 모든 합, x와 y는 주어진 수이다.

for(int i = 0 ; i < n ; i++) 반복문에서
sum - y - a[i] <= a[j] <= sum - x - a[i]
a[j]의 최소값을 lef에 대입한다.
a[j]의 최대값을 righ에 대입한다.

  **1참조
lef, righ를 이진탐색으로 각각 인덱스를 찾아 l, r에 대입해
ans += r - l + 1을 하면
i가 정해졌을 때 조건을 만족하는 j의 개수이다.
위를 좀더 풀어 설명하면
lef부터 righ까지 원소의 개수는 i가 정해졌을 때
x <= sum - a[i] - a[j] <= y 를 만족하는 j의 개수이다.

반복문을 돌며 모든 i에 대해 j의 개수를 ans에 더한다.

  예외 조건
i == j인 경우가 있다.
위의 **1참조 에서 모든 i에 대해서 만족하는 j를 구하면 i == j 인 경우가 있다.
lef <= i <= righ인 경우 ans--을 하면 i == j인 쌍을 없앨 수 있다.

구해진 모든 i, j 쌍은 중복이 있다.
i, j가 서로 바뀐 중복된 쌍이 항상 존재한다.
위의 **1참조 에서 모든 i에 대해 만족하는 j를 모두 구했기 때문이다.
따라서 ans /= 2 를 하면 중복된 쌍을 모두 없앨 수 있다.

  시간 복잡도 - O(nlogn)
for(int i = 0 ; i < n ; i++) 반복문의 시간복잡도는 O(n)이다.
이진탐색으로 l과 r을 구하면 시간복잡도는 O(logn)이다.
따라서 시간복잡도는 O(nlogn)이다.