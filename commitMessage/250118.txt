codeforces/contests/div2 997
------
codeforces/contests/div2 997
https://codeforces.com/contest/2056
------
codeforces/contests/div2 997
A.cpp
  피드백
일단 두가지 방법이 있다. 사람이 이해하기 좋게 푸는 방법과
수학적으로 정리한 간결한 코드가 있다. 
역시 다양한 풀이가 있겠지만, 실수를 안하게, 이해하기 쉬운 방법으로 풀었다.
직관적으로 인덱스마다 그 인덱스의 변의 길이를 구할 수 있다. 모두 더하면 된다.

B.cpp
B2.cpp
  피드백
B의 풀이 방법은 다양하다. 
1. B.cpp 풀이 방법 - 배열의 요소에 숫자를 하나씩 할당하는 방법
위치를 찾아 할당한 요소를 배열에서 없다고 생각하고 반복하며 할당하는 느낌이다.
예를들어 i = 1, j = 2, k = 3 이고 p[i] = 2, p[j] = 2, p[k] = 2일 때 

i = 1 할당
... 0 0 1 0 0
... 0 0 x 0 0
j = 2 할당
... 0 2 x 0 0
... 0 x x 0 0
k = 3 할당
... 3 x x 0 0
... x x x 0 0

1, 2, 3 할당을 마친 뒤 배열은 밑과 같을 것이다.
... 3 2 1 0 0
x표시 된 부분은 연산을 할 때 건너 뛴다는 것이다. 배열에 할당은 되어있다. 0은 아직 할당되지 않은 부분이다.

할당하는 과정에서 예외가 조금 발생할 수 있기 때문에 인덱스 위치를 잘 이해해야하고,
헷갈릴 부분이 조금 있지만 모든 과정을 이해를 하고나면 틀릴 부분이 없다.
이해를 해야하는 부분이 2번보다 많기 때문에 2번이 좋은 풀이지만 역시 좋은 풀이다.

2. B2.cpp 풀이 방법 - sort를 이용한 방법
c++ algorithm 헤더의 sort() 함수를 사용하고, 밑은 코드의 일부이다.
        sort(p.begin(), p.end(),
             [&](int i, int j)
        {
            if(g[i][j] == '1') return i < j;
            else return i > j;
        });
위의 부분이 핵심이고, 풀이의 전부이다.
이해가 크게 어렵지 않다.